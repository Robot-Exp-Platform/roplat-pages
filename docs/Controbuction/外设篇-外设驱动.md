# 外设篇 - 外设驱动

## 任务描述

现有机器人各家都单独为自己的机器人实现了外设驱动，但是这些驱动有好有差，参差不齐，没有安全性和可靠性保障的驱动是不可相信的。在这里，我们需要对一些机器人使用 rust 实现驱动或者封装。

这里说明一下我们常说的 由 rust 实现的原生库 和 由 rust 封装的库 的区别。原生库是指完全由 rust 实现的库，例如你阅读了机器人的完整驱动文件，并且使用 rust 重新实现了这个驱动，这就是原生的；而封装库是指将其他语言的库封装为 rust 的库，列如我们首先使用 C++ 编译获得了一个静态库或者动态库（更多的情况下是商家为了保密措施只为我们提供动态库），然后我们使用 rust 的 FFI 机制将其封装为 rust 的库。

libfranka-rs 是一个 rust 封装库，其本质上是在调用 libfranka 的C++编译后的动态库。
franka-rust 是一个 rust 原生库，使用 rust 重新实现 franka 驱动，但是还没写完（或者说还没开始）。

在本任务中，需要实现几款新机器人的驱动，你应该为每款驱动重新实现一个 rust 版本的驱动，或者封装一个 rust 版本的驱动。一般来说命名规则为： `libxxx-rs` 表示封装了 `libxxx` 的库，`xxx-rs` 表示原生的库。

需要实现驱动的机器人类型有：

1. 未竟的事业 - franka 的原生 rust 实现
2. 大族机器人（可以很轻松的原生实现）
3. 思灵机器人（智能使用 FFI 封装）
4. UR机器人（我没用过不知道）
5. STM32 串口驱动的舵机所代表的机器人（我没用过，但是应该为 stm32 实现一个不依赖芯片型号的驱动，这需要借助宏和HAL层的帮助）

各驱动实现前需要来找我要驱动文档
